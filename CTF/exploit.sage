from sage.all import *
from Crypto.Hash import SHA256
from pwn import *

def ecdsa_sign(m, d, G):
    h = int(SHA256.new(m.encode()).hexdigest(), 16)
    k = randint(1, n-1)
    r = mod((k * G).xy()[0] , n)
    assert r != 0
    s = int(inverse_mod(k, n) * (h + r * d) % n)
    assert s != 0
    return r, s

def translate(type):
    if type == '1':
        return 'MSB'
    elif type == '2':
        return 'LSB'
    else:
        return 'Middle'

def sign(p, type):
    print(p.recvuntil(b"Choose wisely: "))
    p.sendline(b"1")
    p.recvuntil(b"nonce? ")
    p.sendline(type)
    p.recvuntil(b"Message: ")
    p.sendline(b"Hello")

    p.recvline()
    r = int(p.recvline().decode().split()[int(2)], int(16))
    s = int(p.recvline().decode().split()[int(2)], int(16))
    leak = int(p.recvline().decode().split()[int(3)], int(10))
    return r, s, leak, int(SHA256.new(b"Hello").hexdigest(), 16)

def construct_lattice(sigs, n, leak_size, type):
    m = len(sigs)
    Zn = Zmod(n)
    if type == 'MSB':
        factor = 2^(leak_size+1)
        shifter = 2^(256-leak_size)
        B = matrix(ZZ, m+2, m+2)
        for i in range(m):
            r = Zn(sigs[i]["r"])
            s_inv = inverse_mod(sigs[i]["s"], n)
            h = sigs[i]["h"]
            leak = sigs[i]["leak"]
            B[i, i] = factor*n
            B[m, i] = factor*(int(r*s_inv))
            #assert(int(Zn(r*inverse_mod(sigs[i]["s"], n)))  == int(Zn(sigs[i]["r"]*inverse_mod(sigs[i]["s"], n))))
            B[m+1, i] = factor*(leak*shifter - h*s_inv) + n
        B[m, m] = 1
        B[m+1, m+1] = n
    elif type == "LSB":  # LSB
        factor = 2^(leak_size+1)
        B = matrix(ZZ, m+2, m+2)
        shifter = inverse_mod(2^leak_size,n)
        for i in range(m):
            r = Zn(sigs[i]["r"])
            s_inv = inverse_mod(sigs[i]["s"], n)
            h = sigs[i]["h"]
            leak = sigs[i]["leak"]
            B[i, i] = factor*n
            B[m, i] = factor*(int(shifter*r*s_inv))
            B[m+1, i] = factor*int(shifter*(leak - h*s_inv)) + n
        B[m, m] = 1
        B[m+1, m+1] = n
    elif type == "Middle":
        r1 = int(sigs[0]["r"])
        s1 = int(sigs[0]["s"])
        r2 = int(sigs[1]["r"])
        s2 = int(sigs[1]["s"])
        h1 = sigs[0]["h"]
        h2 = sigs[1]["h"]
        leak1 = sigs[0]["leak"] << (256-leak_size[1])
        leak2 = sigs[1]["leak"] << (256-leak_size[1])
        leak_beginning = leak_size[0]
        leak_end = leak_size[1]
        l = 256 - leak_beginning
        K = 2^(max(leak_beginning, 256-leak_end))

        t = -int(inverse_mod(s1, n)*s2*r1*inverse_mod(r2, n))
        u = int(inverse_mod(s1, n)*r1*h2*inverse_mod(r2, n) - inverse_mod(s1, n)*h1)
        u_new = leak1 + t*leak2 + u

        B = matrix(ZZ, 5, 5)
        B[0] = vector(ZZ, [K, K * 2^l, K * t, K * t * 2^l, u_new])
        for i in range(1,4):
            B[i] = vector(ZZ, [0]*i + [K*n] + [0]*(4-i))
        B[4] = vector(ZZ, [0, 0, 0, 0, n])

    else:
        print("Invalid leak type")
        exit()
    return B

def reduce_lattice(B, block_size):
    if block_size is None:
        print("Using LLL")
        return B.LLL()
    print("BKZ with block size {}".format(block_size))
    return B.BKZ(block_size=block_size,  auto_abort = True)

def get_key_msb_lsb(B, Q, n, G):
    Zn = Zmod(n)
    #print("Official public key: {}".format(Q))  
    for v in B:
        potential_key = int(v[-2]) % n
        if potential_key > 0:
            if Q == potential_key*G:
                return potential_key
            elif Q == Zn(-potential_key)*G:
                return Zn(-potential_key)   
    return 0

def solve_system(B, signatures, leak_size, n, G):
    #print(B)
    Zn = Zmod(n)
    r1, s1 = signatures[0]["r"], signatures[0]["s"]
    r2, s2 = signatures[1]["r"], signatures[1]["s"]
    h1, h2 = signatures[0]["h"], signatures[1]["h"]

    leak_beginning = leak_size[0]
    leak_end = leak_size[1]
    leak1 = signatures[0]["leak"] << (256-leak_size[1])
    leak2 = signatures[1]["leak"] << (256-leak_size[1])
    l = 256 - leak_beginning
    K = 2^(max(leak_beginning, 256-leak_end))
    
    t = -inverse_mod(s1, n)*s2*r1*inverse_mod(r2, n)
    u = inverse_mod(s1, n)*r1*h2*inverse_mod(r2, n) - inverse_mod(s1, n)*h1
    u_new = leak1 + t*leak2 + u

    eq_system = Matrix(ZZ, 4, 4)
    b = []
    equation_index = 0
    for v in B[:-1]:
        if not v.is_zero():
            eq_system[equation_index] = [x//K for x in v[:4]]
            b.append(-v[4])
            equation_index += 1

    """
    x -> LSB recovered
    y -> MSB recovered
    """
    x1, y1, x2, y2 = eq_system.solve_right(vector(ZZ, b))
    assert(Zn(x1 + 2^l*y1 + t*x2 + t*2^l*y2 + u_new) == 0)

    k1 = y1*(2^l) + leak1 + x1
    k2 = y2*(2^l) + leak2 + x2
    print("k1: ", k1)
    print("k2: ", k2)

    priv_key1 = Zn(inverse_mod(r1, n)*(s1*k1 - h1))
    priv_key2 = Zn(inverse_mod(r2, n)*(s2*k2 - h2))

    assert(priv_key1 == priv_key2)
    return int(priv_key1)


p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
E = EllipticCurve(GF(p), [0, 7])
G = E.gens()[0] # generator
n = G.order() # order of G

vuln = process(["sage", "vuln.sage"])

vuln.recvuntil(b"Public key: ")
line = vuln.recvline()
Q_coords = line[1:].strip()[:-1].split()
Q = E([int(Q_coords[0]), int(Q_coords[2]), int(Q_coords[4])])

type = b"1"
leak_size = 5   
num_signatures = int(1.03 * (4/3) * (256/leak_size))


if(type == b"3"):
    leak_size = [int(96),int(160)]
    num_signatures = 2

signatures = []

for i in range(num_signatures):
    r, s, leak, h = sign(vuln, type)
    signatures.append({"r":r, "s":s, "leak":leak, "h":h})
    print(signatures[-1])

type = translate(type.decode())
print("Building lattice...")
B = construct_lattice(signatures, n, leak_size, type)
print("Lattice built")
block_sizes = [None, 15, 20, 25, 30, 40, 50, 60, num_signatures]
    
print("Retrieving private key from signatures")
for block_size in block_sizes:
    reduced = reduce_lattice(B, block_size)
    if type == "Middle":
        found = solve_system(reduced, signatures, leak_size, n, G)
    else: # LSB or MSB
        found = get_key_msb_lsb(reduced, Q, n, G)

    if found :
        vuln.recvuntil(b"Choose wisely: ")
        vuln.sendline(b"2")
        vuln.recvuntil(b"Message: ")
        vuln.sendline(b"I'll be back")

        sig = ecdsa_sign("I'll be back", found, G)

        vuln.recvuntil(b"r: ")
        vuln.sendline(hex(sig[0]).encode())
        vuln.recvuntil(b"s: ")
        vuln.sendline(hex(sig[1]).encode())
        print("")
        print("")
        print("")
        print(f"private key recovered: {hex(found)}")
        print(vuln.recvline().decode())
        print(vuln.recvline().decode())
        vuln.recv()
        
        break
    else:
        print("FAILED")

vuln.interactive()